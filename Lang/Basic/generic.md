# 泛型

## 泛型是什么

泛型是一种在强类型编程语言中指定和使用类型参数的功能。它允许你编写可以处理不同数据类型的代码，同时保持类型安全。泛型最常见的用途是在集合和数据结构中，如列表、队列、字典等。

例如，在C#中，你可以创建一个泛型列表：

```csharp
List<T> myList = new List<T>();
```

在这里，`T`是一个类型参数，你可以用任何类型替换它，如`int`、`string`等。这样，你就可以创建一个可以存储特定类型的列表，而不是只能存储对象。

在Java中，泛型的使用方式类似：

```java
List<T> myList = new ArrayList<T>();
```

在这两种情况下，泛型都提供了类型安全，因为你不能将错误的类型添加到列表中，编译器会在编译时检查这一点。同时，当你从列表中获取元素时，你不需要进行类型转换，因为编译器知道元素的类型。

泛型的另一个常见用途是在方法中。你可以创建一个接受类型参数的方法，这样你可以用不同的类型调用同一个方法。例如，在C#中：

```csharp
public T MyMethod<T>(T param)
{
    // do something with param
    return param;
}
```

在这个方法中，`T`是一个类型参数，你可以用任何类型的参数调用这个方法。这样，你就可以避免为每种类型编写一个方法。

## Java泛型规则

1. 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的`<E>`）；
2. 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符；
3. 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符；
4. 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（如`int, char, float`）。
5. 上界通配符`<? extends T>`、下界通配符 `<? super T>`：

   例子：[Java泛型进阶篇: 无界通配符、上界通配符以及下界通配符_java 接口中设置 上界通配符-CSDN博客](https://blog.csdn.net/csdn_mrsongyang/article/details/121578209)
6. Java泛型标识符：



|  E   | Element（在集合中使用，因为集合中存放的是元素） |
| :--: | :---------------------------------------------: |
|  T   |                 Type（Java类）                  |
|  K   |                    Key（键）                    |
|  V   |                   Value（值）                   |
|  N   |               Number（数值类型）                |
|  ?   |      表示不确定的 Java 类型（无界通配符）       |

## 为什么要使用泛型？

- 用泛型只是确定了集合内的元素的类型，但却是在**编译时确定了元素的类型再取出来时已经不再需要强转**， **增强程序可读性，稳定性和效率**；

- 不用泛型时，如果是装入集合操作，那么**元素都被当做`Object`对待**，失去自己的类型，那么从集合中取出来时， 往往**需要转型，效率低，容易产生错误**。

  ```Java
  //使用泛型：
  List<T> list=new ArrayList<T>();  
  T t=list.get(0);//隐式的类型转换
  //不使用泛型：
  List list=new ArrayList();  
  T t=(T)list.get(0);//发生了显式的强制类型转换
  ```
  
  ```java
  List<T> list=new ArrayList<T>(); //你想使用什么类实现的List，就在T内填入对应的类型符号即可。
  //当然，定义类的时候也可以不使用泛型，只不过在具体实例化的时候会发生显式的强制类型转换，可能会报错。
  Set<T> 表示集合里是T类的实例
  List<E> 表示集合是E类的实例
  List<?> 表示集合里的对象类型不确定，未指定；List 同 List<?> 是一样的。
  ```
  
  ## C++中的泛型
  
  在C++中，泛型是通过模板实现的。模板是一种编写代码的方式，可以处理任何类型，而不仅仅是单一的预定义类型。
  
  以下是一个C++模板函数的例子：
  
  ```cpp
  template <typename T>
  T add(T a, T b) {
      return a + b;
  }
  ```
  
  在这个例子中，`typename T`是一个模板参数，表示一个通用的类型。你可以使用任何类型的参数调用`add`函数，例如`int`、`double`、`float`等，只要这些类型支持`+`操作符。
  
  你也可以创建模板类。以下是一个简单的模板类的例子：
  
  ```cpp
  template <typename T>
  class MyGenericClass {
  private:
      T data;
  public:
      MyGenericClass(T d) : data(d) {}
      T getData() { return data; }
  };
  ```
  
  在这个例子中，`MyGenericClass`是一个模板类，它有一个类型为`T`的成员变量`data`。你可以用任何类型创建`MyGenericClass`的实例。
  
  使用模板可以提高代码的复用性，因为你可以用同一份代码处理不同的数据类型。同时，模板也提供了类型安全，因为编译器会在编译时检查类型的正确性。
