# BST的基本方法
BST具有独特的访问数据的方法，即循关键码访问(Call-By-Key)。这主要是通过三种接口完成的，即静态的查找、动态的插入和删除。这三种接口的实现方法是BST的基本方法。

## 查找
1. BST的查找方法：从根节点出发，逐步地缩小查找范围，直到发现目标（成功），或抵达空树（失败）。对照中序遍历序列可见，整个过程可视作是在仿效有序向量的二分查找。（减治）算法的时间复杂度：$O(h)$，其中$h\in[\log n,n]$是BST的深度。

2. 算法实现：

   ```
   算法：binSearch(v, key)
   输入：二叉树中的节点v，一个关键码key
   输出：在以v为根节点的（子）树中，找出关键码为key的节点；若不存在这样的节点，则返回最后被访问的节点
   要求：首次调用时，v为树根节点
   {
       置当前节点u = v;
       不断地迭代 {
           将当前节点u与目标关键码key做比较;
           若目标关键码更小，则
           若u有左孩子，则令u = u.lChild;
           否则（查找失败），直接返回u;
           否则，若若目标关键码更大，则
           若u有右孩子，则令u = u.rChild
           否则（查找失败），直接返回u;
           否则（查找命中），直接返回u;
   	}
   }
   ```

3. 算法的有效性证明：
   1. 正确性：在`binSearch()`算法中每次深入左（右）子树时，被忽略的右（左）子树必然不含目标节点。

   2. 确定性：BST允许多个节点拥有相等的关键码。`binSearch()`算法总能返回最靠近根节点的节点。

      > 引理：
      >
      > 在任一二分查找树T中，若至少存在一个关键码为key的节点，则这些节点中深度最小者必然唯一，而`binSearch()`算法找出的正是这一节点。
      >
      > 证明：
      >
      > 1. 首先证明，若存在关键码相同的节点，则深度最小者必唯一。（反证法）
      >
      >    否则，任取深度最小的两个节点`u`和`v`，令`c`为它们的最低共同祖先。显 然，`u ≠ c ≠ v`，而且`u`和`v`不可能处于`c`的同一侧子树（如果是在同一侧的情况下，命题直接得证）。不失一般性，设`u`、`v`分别属于`c`的左、 右子树。于是便有`key = key (u) ≤  key(c)  ≤  key(v)  =  key`。这与`u`、`v`是关键码为`k ey`的深度最小节点矛盾。
      >
      > 2. 接下来，我们注意到以下事实：在对二分查找树的查找过程中，接受比较的各个节点的深度比然不断递增。因此，在关键码为key的所有节点中，唯一的那个深度最小的节点必然首先接收比较，并使得算法以成功告终。

3. 代码实现：

    ```java
    class Node {
        int key;
        Node left, right;
    
        public Node(int item) {
            key = item;
            left = right = null;
        }
    }
    
    class BinarySearchTree {
        Node root;
        Node search(Node root, int key) {
            if (root == null || root.key == key)
                return root;
    
            if (root.key < key)
                return search(root.right, key);
    
            return search(root.left, key);
        }
    }
    ```

4. 算法的语义：对于返回的引用值：查找成功时，指向一个关键码为e且真实存在的节点；失败时，指向最后一次试图转向的空节点NULL——随后可视需要进行修改。此时，不妨假想地将该空节点转换为一个数值为e的哨兵节点。

## 插入
1. 为了在二分查找树中插入一个节点，我们需要根据其关键码key，利用查找算法`binSearch()`确定插入的位置及方向，然后才将新节点作为叶子插入。

2. 算法实现：

   ```
   算法：insert(v, key, value) 
   输入：以v为根节点的子树，关键码key以及数据value 
   输出：将条目(key, value)插入二分查找树中，并返回该条目 
   { 
       若当前的树为空，则生成并返回一棵包含单节点(key, value)的二分查找树; 
       p = 树根v; 
       while (true) { 
           调用binSearch(p, key), 在以p为根节点的子树中查找关键码为key的最高节点 
           若key ≠ p.key，则根据二者的大小关系将新节点作为p的右或左孩子插入，并返回新节点 
           若key = p.key，则有两种可能： 
           若p没有左或右孩子，则将新节点作为p的左或右孩子插入，并返回新节点; 
           若p已有两个孩子，则取p = p.lChild; 
       } 
   }
   ```

3. 算法的正确性和确定性容易证明。因为该算法和查找算法大体上十分相似。
4. 插入算法的时间复杂度：$O(h)$，其中$h\in[\log n,n]$是BST的深度。

## 删除

1. 为了从二分查找树中删除关键码为key的节点，我们首先也需要通过算法`binSearch()`判断树中是否的确存在这样的节点；如果存在，我们要确定其位置，然后才能将其摘除。

2. 算法实现：

   ```
   算法：remove(r, key) 
   输入：子树r，关键码key 
   输出：若在以r为根节点的子树中存在关键码为key的节点，则删除它，并返回其中存放的条目 
   { 
       调用binSearch(r, key), 在子树r中查找关键码为key的最高节点 
       若key ≠ v.key，则说明目标节不存在，故返回null; 
       若v没有左孩子，则 
       	摘除v，代之以v的右孩子; 
       否则 { 
           在v的左子树中找出其直接前驱w; //请注意，w必然没有右孩子 
           将v与w交换位置; 
           摘除v，代之以v的左孩子; 
       } 
   } 
   ```

3. 删除算法的时间复杂度：$O(h)$，其中$h\in[\log n,n]$是BST的深度。



> 1. 在含n个节点的二叉搜索树（BST）中进行查找的最坏时间复杂度为O(n)。
>
>    这种情况发生在二叉搜索树退化为链表的情况下，即所有节点都只有左子节点或只有右子节点。在这种情况下，查找操作需要遍历所有的节点，因此时间复杂度为O(n)。S
