# 平衡二叉树的实例——AVL树

## AVL树简介

1. AVL树（Adelson-Velsky and Landis Tree）是最先发明的自平衡二叉查找树(1962)。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是$O(\log n)$。

   AVL树的例子：

   ```
       30
      /  \
    15   40
   /  \    \
   10  20   50
   ```

   > **AVL Tree** is a self balancing binary search **tree**, where difference of right subtree and left subtree height to a node is at most 1.

2. 平衡因子：在BST中，任一节点$v$的平衡因子都定义为“其左、右子树的高度差”，记作$balFac(v)=h(ls) - h(rs)$。这里强调，空树的高度为$-1$。

3. AVL树的性质：

   1. 空二叉树是一个 AVL 树；

   2. 如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 $|h(ls) - h(rs)| \leq 1$，h 是其左右子树的高度；

   3. （适度平衡）树高为 $O(\log n)$。（反过来，等价于高度为$h$的AVL树，至少包含$Fib(h+3)-1$个节点）

   >对树高为 $O(\log n)$的证明：设 $f_n$ 为高度为 $n$ 的 AVL 树所包含的最少节点数，则有
   >
   >
   >$$
   >f_n=
   >\begin{cases}
   >1&(n=1)\\
   >2&(n=2)\\
   >f_{n-1}+f_{n-2}+1& (n>2)
   >\end{cases}
   >$$
   >
   >
   >
   >根据常系数非齐次线性差分方程的解法，$\{f_n+1\}$ 是一个斐波那契数列。这里 $f_n$ 的通项为：
   >
   >
   >$$
   >f_n=\frac{5+2\sqrt{5}}{5}\left(\frac{1+\sqrt{5}}{2}\right)^n+\frac{5-2\sqrt{5}}{5}\left(\frac{1-\sqrt{5}}{2}\right)^n-1
   >$$
   >
   >
   >
   >斐波那契数列以指数的速度增长，对于树高 $n$ 有：
   >
   >
   >$$
   >n<\log_{\frac{1+\sqrt{5}}{2}} (f_n+1)<\frac{3}{2}\log_2 (f_n+1)
   >$$
   >
   >
   >
   >因此 AVL 树的高度为 $O(\log f_n)$，这里的 $f_n$ 为结点数。
   
   注意：完全二叉树一定是AVL树，但AVL树不一定是完全二叉树。

## AVL树：失衡和重新平衡

1. AVL树的失衡与重新平衡：AVL树和普通BST最大的不同就是是否满足平衡因子的绝对值小于等于1。对于上述的例子，如果我们要插入元素`25`，则会引起`25`的祖父和曾祖父失衡。此时，该树不再满足AVL树的条件。同样的，如果我们删除某一个节点，也会引起某些节点的失衡。

## 插入——旋转算法

1. AVL树的普通插入方法，和普通BST树的方法完全一致。不过，使用单纯的插入算法，可能会使得原AVL树不满足BBST的条件，而退化成BST。为此，我们必须要升级该方法为插入——旋转算法。

2. **失衡节点集（插入）**：一般地，若在插入新节点$x$之后AVL树T失去平衡，则可以将失衡的节点组成集合$U_T(x)$，则有如下的事实：

   > $U_T(x)$中的每个节点都是x的祖先，且高度不低于x的祖父。
   >
   > （推论）$U_T(x)$中各节点的深度互异，且该集合的规模不超过$\text{depth}(x)-1$。若取$g(x)$为$U_T(x)$中最深的节点，则$g(x)$必然存在且唯一。

3. 思路：为了修正失衡的现象，我们从$x$出发逆行向上，依次检查x各层祖先的平衡因子，直到发现$g(x)$。在$x$与$g(x)$之间的通路上，设$p$为$g(x)$的孩子，$v$为$p$的孩子，则由上述推论，得到：$p$必是$x$的真祖先，而$v$是$x$的祖先。此后，根据祖孙三代$g(x),p,v$的位置关系，对$g(x)$和$p$进行旋转，使得树的局部恢复平衡。这一操作也会使得整棵树的平衡性也得到恢复。

4. 单旋(zig, zag)：假设$v$是$p$的左（右）孩子，且$p$也是$g$的左（右）孩子。这种情况下，一定是由于在子树$v$插入新节点$x$而导致$g$失衡。此时，我们只需要对$g$进行一次顺时针/zig旋转（逆时针/zag旋转）即可。（概括下来，就是：失衡节点获得其孩子的高度较低的子树，然后该失衡节点变为其孩子的子树，局部树的根节点变为原失衡节点的孩子。由于经过插入——旋转操作后整棵树的深度和之前一样，所以其他节点不受影响，而那一系列的失衡节点也同时重新平衡。）

   ![bst-RR](https://oi-wiki.org/ds/images/bst-RR.svg)

5. 双旋(zig-zag, zag-zig)：假设$v$是$p$的右（左）孩子，而$p$是$g$的左（右）孩子。这种情况下，一定是由于在子树$v$插入新节点$x$而导致$g$失衡。此时，我们需要对$p$进行一次逆时针/zag（顺时针/zig）旋转，然后再对$g$进行一次顺时针/zig（逆时针/zag）旋转。（概括下来，就是：失衡节点的孩子先获得其孩子的某棵子树（这里，对子树的选取必须符合BST的有关规则），而后，以该失衡节点的孩子为节点所构成的树变成失衡节点的孙子的一棵子树；现在，情况已经变成了一个单旋的操作，祖孙三代按辈分依次是$g,v,p$。最后经过一次单旋的操作，局部树的根节点变为原失衡节点的孙子。也就是说，孙子在两次旋转操作中，逐渐向根节点靠拢。）

   ![bst-LR](https://oi-wiki.org/ds/images/bst-LR.svg)

5. 插入——旋转算法的效果和效率：我们有以下结论：

   > 1. 在AVL树中插入节点x后，若g(x)是失衡的最低节点，则经过上述单旋或双旋调整之后，不仅能使局部重新平衡同时高度也复原，而且整棵树也将重获平衡。
   > 2. 在AVL树中插入一个节点后，至多只需经过两次旋转即可使之恢复平衡。
   > 3. AVL 树的节点插入操作可以在$O(\log n)$时间内完成。

## 删除——旋转算法

1. AVL树的删除算法：删除节点$x$的操作和BST树的删除算法一致。不过，删除操作可能会导致某个节点失衡。为此，我们需要升级删除算法为删除——旋转算法。

2. **失衡节点集（删除）**：一般地，若在删除节点$x$之后AVL树T失去平衡，则可以将失衡的节点组成集合$V_T(x)$，则有如下的事实：（注意此处的表述和上文不完全一致）

   > $V_T(x)$中的每个节点都是x的祖先。
   >
   > （推论）$V_T(x)$中各节点的深度互异。若取$g(x)$为$V_T(x)$中最深的节点，则$g(x)$必然存在且唯一。

3. 删除——旋转算法的思路：为了修正失衡的现象，我们从$x$出发逆行向上，依次检查x各层祖先的平衡因子，直到发现$g(x)$。其左、右孩子的高度应至少相差2，我们将其中的高者记作p。既然p的高度至少为1，故必有孩子。我们按照以下规则在p的孩子中选出节点v：若p的两个孩子不一样高，则取v为其中的高者；否则，取v与p同向（亦即，v与p同为左孩子，或者同为右孩子）。根据祖孙三代节点g(x)、p和v的位置关系，通过对g(x)和p的旋转同样可以使得这一局部恢复平衡。不过，与插入操作不同的是，删除操作后局部平衡的恢复并不意味着整棵树T的平衡也得到恢复。

4. 局部平衡——单旋：假设v是p的左（右）孩子，且p也是g的左（右）孩子。这种情况下，一定是由于在子树v删除节点x而导致g失衡。此时，我们只需要对g进行一次顺时针/zig旋转（逆时针/zag旋转）即可。

5. 局部平衡——双旋：假设v是p的右（左）孩子，而p是g的左（右）孩子。这种情况下，一定是由于在子树v删除节点x而导致g失衡。此时，我们需要对p进行一次逆时针/zag（顺时针/zig）旋转，然后再对g进行一次顺时针/zig（逆时针/zag）旋转。

6. 从局部平衡到整体平衡：在删除操作中，我们只需对失衡节点的祖孙三代进行一次旋转操作，就可以使得局部树恢复平衡。但是，这并不意味着整棵树也恢复平衡。（原因：当原先的失衡节点只有一棵子树时，若该子树进行删除——旋转操作，则会使得整棵树的高度-1。考虑某一祖先节点：可能进行删除——插入操作的子树恰好处于其高度更低的子树上，那么，当原子树进行删除——旋转操作之后，这个节点就会从原先的满足平衡转变为不满足平衡。）为此，我们需要递归地对祖孙三代的祖先进行旋转操作，直到根节点。这样，整棵树的平衡性也得到恢复。

7. 删除——旋转算法的效果和效率：我们有：

   > 1. 在删除AVL节点后，经过上述单旋或双旋调整，最深失衡节点的深度必然减小。
   > 2. 在AVL树中删除一个节点后，至多只需经过O(logn)次旋转操作即可使之恢复平衡。
   > 3. AVL树的节点删除操作可以在$O(\log n)$时间内完成。

## AVL树的`"3+4"`重构

1. 对上述方法进行改进的原因：上述方法虽然必要简明且富有技巧性，但是，方法的分支太多，无法形成有效的桶一的操作。我们需要寻找一个更高效率的统一的算法。所以，我们需要重新审视上述方法中的三个节点和与其相关的四个子树。

2. 具体步骤：

   1. 命名：设$g(x)$为最低的失衡节点，考察祖孙三代：`g,p,v`，并将它们按照中序遍历的次序重命名，得`a<b<c`。而它们总共拥有互不相交的四棵（可能为空的）子树，同样地，将它们按照中序遍历的次序重命名，得`T0<T1<T2<T3`。所以，我们可以得到一个`3+4`的序列：`T0<a<T1<b<T2<c<T3`。这也是BST单调性的具体体现。
   2. 拼接：现在，按照BST单调性的原则，将这些节点和子树直接地拼接起来。此时，`b`为这个局部BST的根节点。

3. 好处：既可以更加概括、深入的了解上述算法的思想，也可以更加简明、高效、鲁棒地设计上述算法。

4. 算法实现：

   ```java
   public static BinTreePosition rotate(BinTreePosition z) {
   	BinTreePosition	y = tallerChild(z);//取y为z更高的孩子
   	BinTreePosition	x = tallerChild(y);//取x为y更高的孩子
   	boolean cType = z.isLChild();//记录：z是否左孩子
   	BinTreePosition	p = z.getParent();//p为z的父亲
   	BinTreePosition	a, b, c;//自左向右，三个节点
   	BinTreePosition	t0, t1, t2, t3;//自左向右，四棵子树
   	/******** 以下分四种情况 ********/
   	if (y.isLChild()) {//若y是左孩子，则
   		c = z;	t3 = z.getRChild();
   		if (x.isLChild()) {//若x是左孩子
   			b = y;	t2 = y.getRChild();
   			a = x;	t1 = x.getRChild();	t0 = (BSTreeNode)x.getLChild();
   		} else {//若x是右孩子
   			a = y;	t0 = y.getLChild();
   			b = x;	t1 = x.getLChild();	t2 = (BSTreeNode)x.getRChild();
   		}
   	} else {//若y是右孩子，则
   		a = z;	t0 = z.getLChild();
   		if (x.isRChild()) {//若x是右孩子
   			b = y;	t1 = y.getLChild();
   			c = x;	t2 = x.getLChild();	t3 = (BSTreeNode)x.getRChild();
   		} else {//若x是左孩子
   			c = y;	t3 = y.getRChild();
   			b = x;	t1 = x.getLChild();	t2 = (BSTreeNode)x.getRChild();
   		}
   	}
   
   	//摘下三个节点
   	z.secede();
   	y.secede();
   	x.secede();
   
   	//摘下四棵子树
   	if (null != t0) t0.secede();
   	if (null != t1) t1.secede();
   	if (null != t2) t2.secede();
   	if (null != t3) t3.secede();
   
   	//重新链接
   	a.attachL(t0);	a.attachR(t1);	b.attachL(a);
   	c.attachL(t2);	c.attachR(t3);	b.attachR(c);
   
   	//子树重新接入原树
   	if (null != p)
   		if (cType)	p.attachL(b);
   		else p.attachR(b);
   
   	return b;//返回新的子树根
   }//rotate
   ```

   ## 对重构算法的综合评估
   
   1. 优点：无论查找、插入或删除，最坏情况下的复杂度均为$O(\log n)$；存储空间的占用为$O(n)$。
   2. 缺点：
      1. 借助高度或平衡因子，为此需改造元素结构，或额外**封装**（伸展树）；
      2. 实测复杂度与理论值尚有差距：
         1. 插入/删除后的旋转，成本不菲；
         2. 删除操作后，最多需旋转$\Omega(\log n)$次（Knuth：平均仅0.21次）；
         3. 若需频繁进行插入/删除操作，未免得不偿失。
      3. 单次动态调整后，全树拓扑结构的变化量可能高达$\Omega(\log n)$。