# 散列函数

## 什么是哈希函数

1. 哈希函数/散列函数(Hash Function)：要让键值对应到内存中的位置，就要为键值计算索引，也就是计算这个数据应该放到哪里。这个根据键值计算索引的函数就叫做哈希函数，也称散列函数。

## 散列函数的评价标准和设计原则

1. 确定(Determinism)：同一关键码总是被映射至同一地址；
2. 快速(Efficiency)：期望的时间复杂度为$O(1)$；
3. 满射(Surjection)：尽可能充分地利用整个散列空间；
4. 均匀(Uniformly)：关键码映射到散列表各位置的概率尽量接近，以有效避免聚集(Clustering)现象。

## 完美哈希函数(PHF)

1. 完美哈希函数(Perfect Hash Function, PHF)：函数Hash()将$N$个Key映射到$M$个整数上($M\ge N$)，且对于任意的$Key_1$和$Key_2$，$\text{Hash}(Key_1)\neq \text{Hash}(Key_2)$，即是没有冲突的哈希函数，则称之为完美哈希函数。
2. 最小完美哈希函数(Minimal Perfect Hash Function, MPHF)：对于所有的完美哈希函数，若存在一个函数$\text{MinHash}()$，使得$M=N$，则该函数称之为最小完美哈希函数。
3. 在现实情况中，很难构造完美的散列算法。因为通常几乎不可能提前知道要散列的完整数据集。例如，在我们马上将探讨的一个程序中，散列表用于统计文本中的重复单词。由于我们事先不知道哪些单词出现在文本中，就不能编写一个完美的算法。数据仓库的查询索引，还有一些不需要更新且对性能有要求的场景，这个算法是适用的。
4. 通常情况下，PHF或MPHF是针对静态集合的。也就是，在使用PHF或MPHF时，所有的 KEY 值是事先已知并且固定的。不过，也有针对动态集合的一个算法。
5. 使用PHF和MPHF的一般流程
   1. （准备阶段）将已知的所有的 KEY 值传给PHF或MPHF生成算法，生成PHF或MPHF以及相应的数据；（这也是完美hash函数的一大缺点：必须事前必须知道原数据集，并且需要花一定的CPU来生成这个函数。）
   2. （使用阶段）调用已有的PHF或MPHF以及相应的数据快速计算哈希值并进行相应的操作。（其实在实际使用中我们只关心步骤2，但步骤1的生成算法却是PHF或MPHF的关键。）
6. 更多详见：[完美哈希函数(Perfect Hash Function) |博客园 ](https://www.cnblogs.com/eve-walle/archive/2012/09/17/2688914.html)

## 散列函数的某些构造方法
### 整数关键码的散列函数构造
   1. 直接构造法：适用于键值为整数且范围比较小的时候，直接让键值作为数组的下标。

   2. 除余法：$\text{Hash}(key)=key\%M$。适用于键值为整数且范围比较大的时候。一般把键值模一个较大的**质数**作为索引，也就是取$f(x)=x\mod M$作为哈希函数。
      1. 关于M的选择：尽量不要选$M=2^k$类似的数。因为，其等效于只是截取了key的最后k位(Bit)，而前面的$n-k$位没有影响。此时，$key\mod M=key\  \&\ (M-1)$。则若某些数的最后k位相同，就会发生冲突（以同余类构成的集合中的元素全部会冲突）。据说，**M为素数时，数据对散列表的覆盖最充分，分布最均匀**；但实际上，对于理想随机的序列，表长是否素数，无关紧要！而理想随机的序列，出现的概率十分低，在这样的情况下，我们还是应该要选择一个较大的素数M。
      2. 以蝉为师：思考：为什么蝉的生命周期为素数？考虑以特定的步长$S$来遍历数列。令$G=\gcd(S,M)$，并假设有一段连续的地址空间属于哈希表，其长度为$M$。每一次以$S$为步长向前遍历哈希表。注意，最后的位置再次步进可以至于最先的位置。如果能够做到访问所有的位置，我们说其具有均匀性。当且仅当$G=1$时，即$S,M$互素时，其有均匀性。回到之前的问题，其天敌的生命周期为$S$，当蝉的生命周期$M$为素数时，在自然界中，$G=gcd(S,M)=1$的出现频率大大增加，蝉更容易生存。

   3. MAD法：即Multiply-Add-Divide，除余法的改进

      1. 除余法的缺陷：
         1. 不动点：无论表长M取值如何，总有$\text{Hash}(0)\equiv0$；
         2. 相关性（零阶均匀）：$[0,R)$的关键码尽管系平均分配至$M$个桶，但相邻关键码的散列地址也必相邻。

      2. 至少需要达到一阶均匀，以获得更好的随机性，即临近的关键码，其哈希地址不再相邻。高低阶的均匀性需要根据使用场合来确定。
      3. 使用MAD法，构造哈希函数：$\text{hash}(key)=(a\times key+b)\% M$，其中$M$为素数，$a>1,b>0,M\nmid a$。

   4. 数字分析法：抽取key中的某几位，构成地址。

      1. 最简单的例子：取十进制表示的奇数位。

      2. 平方取中(Mid-square)：取key平方的中间若干位，构成地址。

         > 为什么要**取中**？
         >
         > 观察乘法的竖式计算，在答案中，居中的数位由多个数字相加而成，而在两旁的数位由较少的数字加和而成，所以，取中会使得更多的关键码中的数码参与到对地址的贡献中去，即会大大地提高随机性。

   5. 折叠法(folding)：将key分割成等宽的若干段（有自左向右和往复折返等方式），取其总和作为地址。

   6. 位异或法XOR：将key分割成等宽的二进制段有自左向右和往复折返等方式），经异或运算得到地址。

   7. 还有其他的方式，总之，越是**随机**，越是没有规律，越好。

### （伪）随机数发生器

   1. C语言的`rand()`函数可以实现伪随机数。`rand()`函数的代码和下面的类似：

      ```c
      static unsigned long next = 1;
      
      /* RAND_MAX assumed to be 32767 */
      int myrand(void) {
          next = next * 1103515245 + 12345;
          return((unsigned)(next/65536) % 32768);
      }
      
      void mysrand(unsigned seed) {
          next = seed;
      }
      ```

      每一个随机数都是由前一个随机数递推而得，因而更应该称之为“伪随机数”。

   2. （伪）随机数算法和散列函数的关系：散列函数的设计原则和评价标准，也是伪随机数算法的设计原则和评价标准。
      1. 伪随机数算法：$rand( x + 1 )  =  [ a \times rand( x ) ] \% M$，其中$M$为素数，$a>1$。
      2. $hash(key) = rand(key) = [rand(0) \times a^{key}] \% M$
      3. （伪）随机数发生器的实现，因具体平台、不同历史版本而异，创建的散列表可移植性差——故需慎用此法。

### 字符串关键码的散列函数构造
1. 多项式法：由于不支持以字符串作为数组下标，并且将字符串转化成数字存储也可以避免多次进行字符串比较。所以，一般不直接把字符串作为键值，而是先算出字符串的哈希值，再把其哈希值作为键值插入到哈希表里。关于字符串的哈希值，我们一般采用进制的思想，将字符串想象成一个 $a$ 进制的数。那么，对于每一个长度为 $n$ 的字符串 $s$，就有：

   

   $$
   x = s_0 \cdot a^0 + s_1 \cdot a^1 + s_2 \cdot a^2 + \ldots + s_n \cdot a^n
   $$

   

   我们可以将得到的 $x$ 对 $2^{64}$（即 `unsigned long long` 的最大值）取模。这样 `unsigned long long` 的自然溢出就等价于取模操作了。可以使操作更加方便。这种算法的时间复杂度为 $O(n)$，其中 $n$ 为字符串的长度。

2. 多项式法的改进：这种方法对英文字符串非常有效。

   ```cpp
   static size_t hashCode( char s[] ) {
       size_t n = strlen(s); size_t h = 0;
       for ( size_t i = 0; i < n; i++ ) {
           h = (h << 5) | (h >> 27);//将h所代表的32位二进制整数的前5位和后27位交换顺序
           h += s[i];//累计每一位字符的贡献
       } //乘以32，加上扰动，累计贡献
       return h;
   }
   ```

3. 最简单的方法：直接相加法。将每一个字母和一个数字对应起来，用所有数码之和代表哈希。哈希函数为

   

   $$
   Hash(S)=\sum_{c\in S}\text{code(upper(c))}
   $$

   

   不过，这种方式最能造成冲突。如：`hash(I am Lord Voldemort)=hash(Tom Marvolo Riddle)=hash(He's Harry Potter)=196`。所以，必须要解决散列冲突。