# 堆排序(HeapSort)

## 什么是堆排序

1. **堆排序**是由1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W. Floyd)和威廉姆斯(J. Williams)在1964年共同发明了的一种排序算法。

2. 该排序算法分为前后两个阶段。第一阶段，是将待排序的n个元素组织为一个优先队列`Q`，然后，不断地将优先队列中最小的元素摘出，使得它们依次构成一个有序的序列。在堆排序中，第一阶段的建堆操作仅需要花费线性时间$O(n)$，第二阶段反复调用`delMin()`方法，不断地取出`Q`中的最小元素，这样，n次调用需要花费$O(n\log n)$时间，总的时间复杂度为$O(n\log n)$。

> 定理 基于比较操作的排序算法具有$\Omega(n\log n)$的时间复杂度下界。证明详见算法设计与分析的相关章节。

## 就地堆排序(In-place Heapsort)

1. **就地算法(In-place Algorithm)**：除输入本身外只使用常数辅助空间的算法，称作就地算法。

2. 许多情况下，等待排序的$n$个元素都以一个长度为$n$的数组`S[]`形式给出。为此，除了输入数组以外，我们还需要为堆结构消耗$O(n)$的辅助空间。而实际上，这个空间的规模完全可以降低到$O(1)$。

3. 算法思路：算法的总体思路和策略与**选择排序算法**基本相同：将所有词条分成**未排序**和**已排序**两类，不断从前一类中取出最大者，顺序加至后一类中。算法启动之初，所有词条均属于前一类；此后，后一类不断增长；当所有词条都已转入后一类时，即完成排序。

4. 具体的实现：

   1. 将其划分为**前缀H**和与之互补的后缀S，分别对应于上述**未排序**和已排序部分。与常规选择排序算法一样，在算法启动之初H覆盖所有词条，而S为空。注意：这里，若从小到大进行排序，则`H`应为**大根堆**。

   2. 不同之处：整个排序过程中，不论`H`有多少词条，其始终都组织成一个堆。另外，整个算法过程始终满足如下不变性：`H`中的最大词条不会大于`S`中的最小词条——除非二者之一为空，比如算法的初始和终止时刻。

   3. 首先取出`H`中的堆顶`M`，与末单元词条`X`交换。`M`既是当前堆中的最大者，同时根据不变性，也不大于`S`中的任何词条，故如此交换之后`M`必处于正确的排序位置。此时，可以等效地认为`S`扩大了一个单元，而`H`相应地缩小了一个单元。这里，`H`和`S`仍然满足不变性。

   4. 有很大的可能，`X`不能称为堆顶，否则会破坏堆的堆序性。此时，可以对`X`进行下滤，就能使得`H`的堆序性重新恢复。

      > 对于大根堆的下滤操作，交换时应选择其两个孩子的最大者。

   5. 重复第3，4步，直到整个排序完成。

5. 复杂度：在每一步迭代中，交换`M`和`X`只需常数时间，对`X`的下滤调整不超过$O(\log n)$时间。因此，全部$n$步迭代累计耗时不超过$O(n\log n)$。即便使用蛮力算法而不是Floyd算法来完成`H`的初始化， 整个算法的运行时间也不超过$O(n\log n)$。