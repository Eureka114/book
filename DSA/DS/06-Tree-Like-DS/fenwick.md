# Fenwick Tree

## Fenwick树的简介

1. Fenwick树（二叉索引树、树状数组）是一种数据结构，用于有效地计算数字序列（数组）的前缀和。它也被称为芬威克树，因为彼得·芬威克通过他的论文将其介绍给世界。

2. Fenwick树虽然名字叫二叉索引树，但是，它不算是一棵二叉树。

3. 树状数组是一种支持 **单点修改** 和 **区间查询** 的，代码量小的数据结构。普通树状数组维护的信息及运算要满足 **结合律** 且 **可差分**，如加法（和）、乘法（积）、异或等。

	> - 模意义下的乘法若要可差分，需保证每个数都存在逆元（模数为质数时一定存在）；
	> - 例如 $\gcd,\max$ 这些信息不可差分，所以不能用普通树状数组处理，但是，使用两个树状数组可以用于处理区间最值。

4. 事实上，树状数组能解决的问题是线段树能解决的问题的子集：树状数组能做的，线段树一定能做；线段树能做的，树状数组不一定可以。然而，树状数组的代码要远比线段树短，时间效率常数也更小，因此仍有学习价值。有时候，在差分数组和辅助数组的帮助下，树状数组还可以解决更强的 **区间加端点值** 和 **区间加区间和** 的问题。

## Fenwick树

### 初步认识
1. 例子：求$a[1,\ldots,7]$ 的前缀和。我们可以将数组中的每一项相加作为最终的答案。但，如果已知三个数 $A,B,C$，且$A = a[1 \ldots 4]$ 的和，$B = a[5 \ldots 6]$ 的总和，$C = a[7 \ldots 7]$ 的总和（其实就是 $a[7]$ 自己），我们就会直接把 A,B,C 相加，作为我们的和。这就是树状数组何以快速求解信息的原因：我们总能将一段前缀 $[1, n]$ 拆成 **不多于 $\log n$ 段区间**，使得这 $\log n$ 段区间的信息是 **已知的**。所以，合并这$\log n$段信息就能得到答案。相较于原来的直接合并 $n$ 个信息，效率有了很大的提高。
2. 树状数组的工作原理如下，其中，$c[x]$ 管辖的一定是一段右边界是 $x$ 的区间总信息。
	![oi-wiki.org/ds/images/fenwick.svg](https://oi-wiki.org/ds/images/fenwick.svg)

3. 例子：计算 $a[4 \ldots 7]$ 的和。我们是从 $c_7$ 开始跳，跳到 $c_6$ 再跳到 $c_4$。此时我们发现它管理了 $a[1 \ldots 4]$ 的和，但是我们不想要 $a[1 \ldots 3]$ 这一部分，怎么办呢？很简单，减去 $a[1 \ldots 3]$ 的和就行了。那不妨考虑最开始，就将查询 $a[4 \ldots 7]$ 的和转化为查询 $a[1 \ldots 7]$ 的和，以及查询 $a[1 \ldots 3]$ 的和，最终将两个结果作差。这就是树状数组的查询过程。

### 管辖区间
一个节点 $c[x]$ 管辖的区间是 $[x - lowbit(x) + 1, x]$。其中，$lowbit(x) = x \& -x$。

> 树状数组中，规定 $c[x]$ 管辖的区间长度为 $2^{k}$，其中：
>
> -   设二进制最低位为第 $0$ 位，则 $k$ 恰好为 $x$ 二进制表示中，最低位的 `1` 所在的二进制位数；
> -   $2^k$（$c[x]$ 的管辖区间长度）恰好为 $x$ 二进制表示中，最低位的 `1` 以及后面所有 `0` 组成的数。
> -   这里注意：$lowbit$ 指的不是最低位 `1` 所在的位数 $k$，而是这个 `1` 和后面所有 `0` 组成的 $2^k$。



> - lowbit的原理：
>
> -   设原先 `x` 的二进制编码是 `(...)10...00`，全部取反后得到 `[...]01...11`，加 `1` 后得到 `[...]10...00`，也就是 `-x` 的二进制编码了。这里 `x` 二进制表示中第一个 `1` 是 `x` 最低位的 `1`。
>
> 	`(...)` 和 `[...]` 中省略号的每一位分别相反，所以 `x & -x = (...)10...00 & [...]10...00 = 10...00`，得到的结果就是 `lowbit`。


### 区间查询
1. 其实任何一个区间查询都可以这么做：查询 $a[l \ldots r]$ 的和，就是 $a[1 \ldots r]$ 的和减去 $a[1 \ldots l - 1]$ 的和，从而把区间问题转化为前缀问题，更方便处理。事实上，将有关 $l \ldots r$ 的区间询问转化为 $1 \ldots r$ 和 $1 \ldots l - 1$ 的前缀询问再差分，在竞赛中是一个非常常用的技巧。

2. 前缀查询：查询 $a[1 \ldots x]$ 的和的过程如下：

	> -   从 $c[x]$ 开始往前跳，有 $c[x]$ 管辖 $a[x-\text{lowbit}(x)+1 \ldots x]$；
	> -   令 $x \gets x - \text{lowbit}(x)$，如果 $x = 0$ 说明已经跳到尽头了，终止循环；否则回到第一步。
	> -   将跳到的 $c$ 合并。

	实现时，我们不一定要先把 $c$ 都跳出来然后一起合并，可以边跳边合并。

### 树状数组与其树形态的性质
1. 我们约定：
     1. $l(x) = x - \text{lowbit}(x) + 1$。即，$l(x)$ 是 $c[x]$ 管辖范围的左端点。
     2. 对于任意正整数 $x$，总能将 $x$ 表示成 $s \times 2^{k + 1} + 2^k$ 的形式，其中 $lowbit(x) = 2^k$。
     3. 下面「$c[x]$ 和 $c[y]$ 不交」指 $c[x]$ 的管辖范围和 $c[y]$ 的管辖范围不相交，即 $[l(x), x]$ 和 $[l(y), y]$ 不相交。「$c[x]$ 包含于 $c[y]$」等表述同理。

2. 性质1：对于$x\le y$，要么$c[x]$ 和 $c[y]$ 不交，要么$c[x]$ 包含于 $c[y]$。

  > 证明：设 $x = s \times 2^{k + 1} + 2^k$，$y = t \times 2^{l + 1} + 2^l$，其中 $s,t$ 为非负整数，$k,l$ 为非负整数。不妨设 $k \le l$。
  >
  > -   若 $k = l$，则 $x = y$，显然不交。
  > -   若 $k < l$，则 $x \le y - 2^l < y$，即 $c[x]$ 包含于 $c[y]$。

3. 性质2：$c[x]$真包含于$c[y]$当且仅当$x = y - \text{lowbit}(y)$。

  > 证明：$c[x]$ 包含于 $c[y]$，则 $l(y) \le l(x) \le x \le y$，即 $l(y) = x$。反之，若 $x = y - \text{lowbit}(y)$，则 $l(y) = y - \text{lowbit}(y) + 1 = x$，即 $c[x]$ 包含于 $c[y]$。

4. 性质3：对于任意$x<y<x+\text{lowbit}(x)$，有$c[x]$和$c[y]$不交。

  > 证明：设$x = s \times 2^{k + 1} + 2^k$，$y = t \times 2^{l + 1} + 2^l$，其中$s,t$为非负整数，$k,l$为非负整数。不妨设$k \le l$。
  >
  > -   若$k = l$，则$x = y$，显然不交。
  > -   若$k < l$，则$x < y - 2^l < x + 2^k$，即$c[x]$和$c[y]$不交。

5. 观察树状数组的形态：对于上图来说，忽略a向c的连边，树状数组的形态是$x$向$x+\text{lowbit}(x)$连边得到的图，其中 $x + \text{lowbit}(x)$ 是 $x$ 的父亲。这棵可以认为是无限大的树有很多好的性质：

> -   $u < fa[u]$。
> -   $u$ 大于任何一个 $u$ 的后代，小于任何一个 $u$ 的祖先。
> -   点 $u$ 的 $\text{lowbit}$ 严格小于 $fa[u]$ 的 $\text{lowbit}$。
> -   $c[u]$ 真包含于 $c[fa[u]]$（性质 $2$）。
> -   $c[u]$ 真包含于 $c[v]$，其中 $v$ 是 $u$ 的任一祖先（在上一条性质上归纳）。
> -   $c[u]$ 真包含 $c[v]$，其中 $v$ 是 $u$ 的任一后代（上面那条性质 $u$，$v$ 颠倒）。
> -   对于任意 $v' > u$，若 $v'$ 不是 $u$ 的祖先，则 $c[u]$ 和 $c[v']$ 不交。
> -   对于任意 $v < u$，如果 $v$ 不在 $u$ 的子树上，则 $c[u]$ 和 $c[v]$ 不交（上面那条性质 $u$，$v'$ 颠倒）。
> -   对于任意 $v > u$，当且仅当 $v$ 是 $u$ 的祖先，$c[u]$ 真包含于 $c[v]$（上面几条性质的总结）。这就是树状数组单点修改的核心原理。
> -   设 $u = s \times 2^{k + 1} + 2^k$，则其儿子数量为 $k = \log_2\text{lowbit}(u)$，编号分别为 $u - 2^t(0 \le t < k)$。
> -   $u$的所有儿子对应的管辖区间恰好拼接成$[l(u),u-1]$。



## 单点修改



## 区间加区间和



## 参考文献

1. Fenwick, P. M. . (2010). A new data structure for cumulative frequency tables. Soft.pract.exp, 24(3), 327-336.