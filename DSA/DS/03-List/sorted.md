

# 有序列表

1. 唯一化：和向量的基本思路大致相同，不同的是，在列表中，可以直接进行删除操作，而不必和向量一样间接地进行删除的操作。时间复杂度：$O(n)$。

   算法过程：只保留每个相等元素区间的第一个元素。

   ```c++
   template <typename T> Rank List<T>::uniquify() { //成批剔除重复元素，效率更高
       if ( _size < 2 ) return 0; //平凡列表，自然不含相等元素
       Rank oldSize = _size; //记录原规模
       ListNodePosi<T> p = first(); ListNodePosi<T> q; //p为各区段起点，q为其后继
       while ( trailer != ( q = p->succ ) ) //反复考查紧邻的节点对(p, q)
           if ( p->data != q->data ) p = q; //若互异，则转向下一区段
           else remove( q ); //否则（相等）直接删除后者，不必如向量那样间接地完成删除
       return oldSize - _size; //列表规模变化量，即被删除元素总数
   }
   ```

2. 查找：和无序列表、有序向量的查找思路相似：从后向前地查找每一个节点，直至某一个节点的值大于或小于（查找失败）或等于（查找成功）。时间复杂度：最好情况下$O(1)$，最坏情况下为$O(n)$——总体上，仍为$O(n)$。这里，我们不能在有序列表中用二分查找使得时间复杂度降低至$\Theta(\log n)$，因为列表不能高效地循秩访问。例如，二分查找的第一步——定位到中点，访问模式为循位置访问的数据结构（如列表）所用的时间就为$\Theta(n)$。

3. 列表和向量的不同之处：

   | 比较对象 | 访问特点 | 应用实例 |
   | :------: | :------: | :------: |
   |  Vector  |   Rank   |   RAM    |
   |   List   | Position |    TM    |

   > 注：RAM模型属于循秩访问的典型模型：给出一个秩（下标），它可以在$O(1)$的时间内访问；而TM模型属于循位置访问的模型，它只能选择向左或向右访问相邻的内容，而对更远的内容，只能一步一步的前往并访问。
   >
   > Call-by-Rank和Call-by-Position这两种访问模式均存在自己的优势和不足之处，要根据不同的问题，选择不同的访问模式和相对应的数据结构。